//======================================================================================================================
//
//	爆弾処理 [bomb.cpp]
//	Author：藤田勇一
//
//======================================================================================================================
//**********************************************************************************************************************
//	インクルードファイル
//**********************************************************************************************************************
#include "main.h"
#include "bomb.h"
#include "player.h"
#include "Police.h"

#include "input.h"
#include "particle.h"
#include "object.h"

//**********************************************************************************************************************
//	マクロ定義
//**********************************************************************************************************************
#define MAX_BOMB	(128)	// 爆弾の範囲内表示の最大数

//**********************************************************************************************************************
//	列挙型定義 (CARTYPE)
//**********************************************************************************************************************
typedef enum
{
	CARTYPE_NORMAL = 0,		// 通常車
	CARTYPE_POLICE,			// 警察車
	CARTYPE_MAX,			// この列挙型の総数
} CARTYPE;

//**********************************************************************************************************************
//	構造体定義 (Bomb)
//**********************************************************************************************************************
typedef struct
{
	D3DXVECTOR3 pos;		// 位置
	BOMBSTATE   state;		// 状態
	CARTYPE     type;		// 種類
	void       *pCar;		// 車アドレス
	bool        bUse;		// 使用状況
}Bomb;

//**********************************************************************************************************************
//	プロトタイプ宣言
//**********************************************************************************************************************
void CollisionHoming(void);									// ホーミング検知範囲の当たり判定
void SetRange(D3DXVECTOR3 pos, CARTYPE type, void *pCar);	// ホーミングの設定
int  CurrentAim(void);										// 選択中の車両

//**********************************************************************************************************************
//	グローバル変数
//**********************************************************************************************************************
CARTYPE g_nType;			// 現在狙い中の車の種類
int     g_nID;				// 現在狙い中の車のID
void   *g_pCurrentAim;		// 現在狙い中の車のアドレス
Bomb    g_aBomb[MAX_BOMB];	// 爆弾の情報

//======================================================================================================================
//	爆弾の初期化処理
//======================================================================================================================
void InitBomb(void)
{
	// グローバル変数を初期化
	g_nType       = CARTYPE_NORMAL;	// 現在狙い中の車の種類
	g_nID         = 0;				// 現在狙い中の車のID
	g_pCurrentAim = NULL;			// 現在狙い中の車のアドレス

	// 爆弾の情報の初期化
	for (int nCntBomb = 0; nCntBomb < MAX_BOMB; nCntBomb++)
	{ // 爆弾の最大表示数分繰り返す

		g_aBomb[nCntBomb].pos   = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 位置
		g_aBomb[nCntBomb].state = BOMBSTATE_NONE;					// 状態
		g_aBomb[nCntBomb].pCar  = NULL;								// 車アドレス
		g_aBomb[nCntBomb].bUse  = false;							// 使用状況
	}
}

//======================================================================================================================
//	爆弾の終了処理
//======================================================================================================================
void UninitBomb(void)
{
	
}

//======================================================================================================================
//	爆弾の更新処理
//======================================================================================================================
void UpdateBomb(void)
{
	// 変数を宣言
	int nAim = -1;

	// ホーミング検知範囲の当たり判定
	CollisionHoming();

	if (GetKeyboardTrigger(DIK_RETURN) == true)
	{

		g_pCurrentAim = g_aBomb[g_nID].pCar;
		g_nID = (g_nID + 1) % 10;
	}

	// 選択中の車両
	nAim = CurrentAim();

	if (nAim == -1)
	{
		g_pCurrentAim = NULL;
	}

	if (g_aBomb[nAim].bUse == true)
	{ // 

		// パーティクルの設定
		SetParticle
		( // 引数
			g_aBomb[nAim].pos,					// 位置
			D3DXCOLOR(0.8f, 0.0f, 0.3f, 1.0f),	// 色
			PARTICLETYPE_DAMAGE,				// 種類
			SPAWN_PARTICLE_DAMAGE,				// エフェクト数
			2									// 寿命
		);
	}

	for (int nCntBomb = 0; nCntBomb < MAX_BOMB; nCntBomb++)
	{ // 爆弾の最大表示数分繰り返す

		// 使用していない状態にする
		g_aBomb[nCntBomb].bUse = false;
	}
}

//======================================================================================================================
//	爆弾の描画処理
//======================================================================================================================
void DrawBomb(void)
{
	
}

//======================================================================================================================
//	ホーミング検知範囲の当たり判定
//======================================================================================================================
void CollisionHoming(void)
{
#define HOM_PULS	(400.0f)	// プレイヤー位置からホーミング検知の中心位置へのずれ
#define HOM_RADIUS	(400.0f)	// ホーミング検知範囲の半径

	// 変数を宣言
	D3DXVECTOR3 rangePos;	// ホーミングの検知範囲の中心
	float       fLength;	// 検知範囲と検知車の距離

	// ポインタを宣言
	Player *pPlayer = GetPlayer();		// プレイヤーの情報
	Police *pPolice = GetPoliceData();	// 警察の情報
	Object *pObject = GetObjectData();	// オブジェクトの情報

	// ホーミングの検知範囲の中心を設定
	rangePos.x = pPlayer->pos.x + sinf(pPlayer->rot.y) * HOM_PULS;
	rangePos.y = pPlayer->pos.y + 0.0f;
	rangePos.z = pPlayer->pos.z + cosf(pPlayer->rot.y) * HOM_PULS;

	for (int nCntPolice = 0; nCntPolice < MAX_POLICE; nCntPolice++, pPolice++)
	{ // 警察の最大表示数分繰り返す

		if (pPolice->bUse == true)
		{ // 警察が使用されている場合

			// 検知範囲と検知車の距離を求める
			fLength = (rangePos.x - pPolice->pos.x) * (rangePos.x - pPolice->pos.x)
					+ (rangePos.z - pPolice->pos.z) * (rangePos.z - pPolice->pos.z);

			if (fLength < ((HOM_RADIUS + 60.0f) * (HOM_RADIUS + 60.0f)))
			{ // 検知範囲内の場合

				// ホーミングの設定
				SetRange(pPolice->pos, CARTYPE_POLICE, pPolice);
			}
		}
	}

	for (int nCntObject = 0; nCntObject < MAX_OBJECT; nCntObject++, pObject++)
	{ // 警察の最大表示数分繰り返す

		if (pObject->bUse == true)
		{ // 警察が使用されている場合

			// 検知範囲と検知車の距離を求める
			fLength = (rangePos.x - pObject->pos.x) * (rangePos.x - pObject->pos.x)
					+ (rangePos.z - pObject->pos.z) * (rangePos.z - pObject->pos.z);

			if (fLength < ((HOM_RADIUS + 60.0f) * (HOM_RADIUS + 60.0f)))
			{ // 検知範囲内の場合

				// ホーミングの設定
				SetRange(pObject->pos, CARTYPE_NORMAL, pObject);
			}
		}
	}
}

//======================================================================================================================
//	ホーミングの設定
//======================================================================================================================
void SetRange(D3DXVECTOR3 pos, CARTYPE type, void *pCar)
{
	for (int nCntBomb = 0; nCntBomb < MAX_BOMB; nCntBomb++)
	{ // 爆弾の最大表示数分繰り返す

		if (g_aBomb[nCntBomb].bUse == false)
		{ // 爆弾が使用されていない場合

			// 引数を設定
			g_aBomb[nCntBomb].pos  = pos;	// 位置
			g_aBomb[nCntBomb].type = type;	// 種類
			g_aBomb[nCntBomb].pCar = pCar;	// 車アドレス

			// 使用している状態にする
			g_aBomb[nCntBomb].bUse = true;

			// 処理を抜ける
			break;
		}
	}
}

//======================================================================================================================
//	選択中の車両
//======================================================================================================================
int CurrentAim(void)
{
	for (int nCntBomb = 0; nCntBomb < MAX_BOMB; nCntBomb++)
	{ // 爆弾の最大表示数分繰り返す

		if (g_aBomb[nCntBomb].bUse == true)
		{ // 爆弾が使用されている場合

			if (g_pCurrentAim == g_aBomb[nCntBomb].pCar)
			{ // アドレスが同じ場合 (選択中の車)

				// 選択中のインデックスを返す
				return nCntBomb;
			}
		}
	}

	// 選択中のインデックスがない場合
	return -1;	// -1を返す
}

#ifdef _DEBUG	// デバッグ処理
#endif