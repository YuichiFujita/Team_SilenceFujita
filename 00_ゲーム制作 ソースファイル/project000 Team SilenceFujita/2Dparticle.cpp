//======================================================================================================================
//
//	2Dパーティクル処理 [2Dparticle.cpp]
//	Author：小原立暉
//
//======================================================================================================================
//**********************************************************************************************************************
//	インクルードファイル
//**********************************************************************************************************************
#include "2Dparticle.h"
#include "2Deffect.h"

//**********************************************************************************************************************
//	マクロ定義
//**********************************************************************************************************************
#define MAX_PARTICLE	(128)	// パーティクルの最大数

//**********************************************************************************************************************
//	構造体定義 (2DParticle)
//**********************************************************************************************************************
typedef struct
{
	D3DXVECTOR3  pos;			// 位置
	D3DXCOLOR    col;			// 色
	int          nSpawn;		// エフェクト数
	int          nLife;			// 寿命
	bool         bUse;			// 使用状況
}Particle2D;

//**********************************************************************************************************************
//	プロトタイプ宣言
//**********************************************************************************************************************
void Particle2DScoreFire(Particle2D *pParticle);						// スコア加算時の花火エフェクト
void Particle2DBonusFire(Particle2D *pParticle);						// ボーナス出現時の花火エフェクト
void Particle2DStart(Particle2D *pParticle);							// スタート時のエフェクト

//**********************************************************************************************************************
//	グローバル変数
//**********************************************************************************************************************
Particle2D g_a2DParticle[MAX_PARTICLE];				// パーティクルの情報

//======================================================================================================================
//	パーティクルの初期化処理
//======================================================================================================================
void Init2DParticle(void)
{
	// パーティクルの情報の初期化
	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		g_a2DParticle[nCnt2DParticle].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 位置
		g_a2DParticle[nCnt2DParticle].col = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);	// 色
		g_a2DParticle[nCnt2DParticle].nSpawn = 0;								// エフェクト数
		g_a2DParticle[nCnt2DParticle].nLife = 0;								// 寿命
		g_a2DParticle[nCnt2DParticle].bUse = false;								// 使用状況
	}
}

//======================================================================================================================
//	パーティクルの終了処理
//======================================================================================================================
void Uninit2DParticle(void)
{

}

//======================================================================================================================
//	パーティクルの更新処理
//======================================================================================================================
void Update2DParticle(void)
{
	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		if (g_a2DParticle[nCnt2DParticle].bUse == true)
		{ // パーティクルが使用されている場合

			// 寿命を減らす
			g_a2DParticle[nCnt2DParticle].nLife--;

			if (g_a2DParticle[nCnt2DParticle].nLife <= 0)
			{ // 寿命が尽きた場合

				// 使用されていない状態にする
				g_a2DParticle[nCnt2DParticle].bUse = false;
			}
		}
	}
}

//======================================================================================================================
//	パーティクルの描画処理
//======================================================================================================================
void Draw2DParticle(void)
{

}

//======================================================================================================================
//	パーティクルの設定処理
//======================================================================================================================
void Set2DParticle(D3DXVECTOR3 pos, D3DXCOLOR col, PARTICLE2DTYPE type, int nSpawn, int nLife)
{
	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		if (g_a2DParticle[nCnt2DParticle].bUse == false)
		{ // パーティクルが使用されていない場合

			// 引数を代入
			g_a2DParticle[nCnt2DParticle].pos	 = pos;		// 位置
			g_a2DParticle[nCnt2DParticle].col	 = col;		// 色
			g_a2DParticle[nCnt2DParticle].nSpawn = nSpawn;	// エフェクト数
			g_a2DParticle[nCnt2DParticle].nLife	 = nLife;	// 寿命

			switch (type)
			{
			case PARTICLE2DTYPE_SCORE_FIRE:		// スコア加算時の花火

				// スコア加算時の花火エフェクト
				Particle2DScoreFire(&g_a2DParticle[nCnt2DParticle]);

				break;							// 抜け出す

			case PARTICLE2DTYPE_BONUS_FIRE:		// ボーナス出現時の花火

				// ボーナス出現時の花火エフェクト
				Particle2DBonusFire(&g_a2DParticle[nCnt2DParticle]);

				break;							// 抜け出す

			case PARTICLE2DTYPE_START:			// スタート時

				// スタート時のエフェクト
				Particle2DStart(&g_a2DParticle[nCnt2DParticle]);

				break;							// 抜け出す
			}

			// 使用している状態にする
			g_a2DParticle[nCnt2DParticle].bUse = true;

			// 処理を抜ける
			break;
		}
	}
}

//======================================================================================================================
// スコア加算時の花火エフェクト
//======================================================================================================================
void Particle2DScoreFire(Particle2D *pParticle)
{
	// 変数を宣言
	D3DXVECTOR3 move;	// エフェクトの移動量の代入用

	for (int nCntAppear = 0; nCntAppear < pParticle->nSpawn; nCntAppear++)
	{ // パーティクルの 1Fで生成されるエフェクト数分繰り返す

		// ベクトルをランダムに設定
		move.x = sinf((float)(rand() % 629 - 314) / 100.0f);
		move.y = cosf((float)(rand() % 629 - 314) / 100.0f);
		move.z = 0.0f;

		// ベクトルを正規化
		D3DXVec3Normalize(&move, &move);

		// 移動量を乗算
		move.x *= (float)(rand() % 6) + 2.0f;
		move.y *= (float)(rand() % 6) + 2.0f;

		// エフェクトの設定
		Set2DEffect
		( // 引数
			pParticle->pos, // 位置
			move, 			// 移動量
			pParticle->col, // 色
			30, 			// 寿命
			30.0f, 			// 半径
			0.5f			// 減衰係数
		);
	}
}

//======================================================================================================================
// ボーナス出現時の花火エフェクト
//======================================================================================================================
void Particle2DBonusFire(Particle2D *pParticle)
{
	// 変数を宣言
	D3DXVECTOR3 move;	// エフェクトの移動量の代入用

	for (int nCntAppear = 0; nCntAppear < pParticle->nSpawn; nCntAppear++)
	{ // パーティクルの 1Fで生成されるエフェクト数分繰り返す

		// ベクトルをランダムに設定
		move.x = sinf((float)(rand() % 629 - 314) / 100.0f);
		move.y = cosf((float)(rand() % 629 - 314) / 100.0f);
		move.z = 0.0f;

		// ベクトルを正規化
		D3DXVec3Normalize(&move, &move);

		// 移動量を乗算
		move.x *= (float)(rand() % 6) + 2.0f;
		move.y *= (float)(rand() % 6) + 2.0f;

		// エフェクトの設定
		Set2DEffect
		( // 引数
			pParticle->pos, // 位置
			move, 			// 移動量
			pParticle->col, // 色
			30, 			// 寿命
			15.0f, 			// 半径
			0.2f			// 減衰係数
		);
	}
}

//======================================================================================================================
// スタート時のエフェクト
//======================================================================================================================
void Particle2DStart(Particle2D *pParticle)
{
	// 変数を宣言
	D3DXVECTOR3 move;	// エフェクトの移動量の代入用

	for (int nCntAppear = 0; nCntAppear < pParticle->nSpawn; nCntAppear++)
	{ // パーティクルの 1Fで生成されるエフェクト数分繰り返す

		// ベクトルをランダムに設定
		move.x = sinf((float)(rand() % 629 - 314) / 100.0f);
		move.y = cosf((float)(rand() % 629 - 314) / 100.0f);
		move.z = 0.0f;

		// ベクトルを正規化
		D3DXVec3Normalize(&move, &move);

		// 移動量を乗算
		move.x *= (float)(rand() % 6) + 4.0f;
		move.y *= (float)(rand() % 6) + 4.0f;

		// エフェクトの設定
		Set2DEffect
		( // 引数
			pParticle->pos, // 位置
			move, 			// 移動量
			pParticle->col, // 色
			30, 			// 寿命
			30.0f, 			// 半径
			1.0f			// 減衰係数
		);
	}
}

#ifdef _DEBUG	// デバッグ処理
//======================================================================================================================
//	デバッグ処理一覧
//======================================================================================================================
//**********************************************************************************************************************
//	パーティクルの総数取得処理
//**********************************************************************************************************************
int GetNum2DParticle(void)
{
	// 変数を宣言
	int nNum2DParticle = 0;	// パーティクルの総数の確認用

	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		if (g_a2DParticle[nCnt2DParticle].bUse == true)
		{ // パーティクルが使用されている場合

		  // カウンターを加算
			nNum2DParticle++;
		}
	}

	// 変数の値を返す
	return nNum2DParticle;	// パーティクルの総数
}
#endif