//======================================================================================================================
//
//	2Dパーティクル処理 [2Dparticle.cpp]
//	Author：小原立暉
//
//======================================================================================================================
//**********************************************************************************************************************
//	インクルードファイル
//**********************************************************************************************************************
#include "2Dparticle.h"
#include "2Deffect.h"

//**********************************************************************************************************************
//	マクロ定義
//**********************************************************************************************************************
#define MAX_PARTICLE	(128)	// パーティクルの最大数

//**********************************************************************************************************************
//	構造体定義 (2DParticle)
//**********************************************************************************************************************
typedef struct
{
	D3DXVECTOR3  pos;			// 位置
	D3DXCOLOR    col;			// 色
	int          nSpawn;		// エフェクト数
	int          nLife;			// 寿命
	bool         bUse;			// 使用状況
}Particle2D;

//**********************************************************************************************************************
//	プロトタイプ宣言
//**********************************************************************************************************************
void Particle2DBonus(Particle2D *p2DParticle);		// ダメージエフェクト

//**********************************************************************************************************************
//	グローバル変数
//**********************************************************************************************************************
Particle2D g_a2DParticle[MAX_PARTICLE];				// パーティクルの情報

//======================================================================================================================
//	パーティクルの初期化処理
//======================================================================================================================
void Init2DParticle(void)
{
	// パーティクルの情報の初期化
	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		g_a2DParticle[nCnt2DParticle].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 位置
		g_a2DParticle[nCnt2DParticle].col = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);	// 色
		g_a2DParticle[nCnt2DParticle].nSpawn = 0;								// エフェクト数
		g_a2DParticle[nCnt2DParticle].nLife = 0;								// 寿命
		g_a2DParticle[nCnt2DParticle].bUse = false;								// 使用状況
	}
}

//======================================================================================================================
//	パーティクルの終了処理
//======================================================================================================================
void Uninit2DParticle(void)
{

}

//======================================================================================================================
//	パーティクルの更新処理
//======================================================================================================================
void Update2DParticle(void)
{
	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		if (g_a2DParticle[nCnt2DParticle].bUse == true)
		{ // パーティクルが使用されている場合

			// 寿命を減らす
			g_a2DParticle[nCnt2DParticle].nLife--;

			if (g_a2DParticle[nCnt2DParticle].nLife <= 0)
			{ // 寿命が尽きた場合

			  // 使用されていない状態にする
				g_a2DParticle[nCnt2DParticle].bUse = false;
			}
		}
	}
}

//======================================================================================================================
//	パーティクルの描画処理
//======================================================================================================================
void Draw2DParticle(void)
{

}

//======================================================================================================================
//	パーティクルの設定処理
//======================================================================================================================
void Set2DParticle(D3DXVECTOR3 pos, D3DXCOLOR col, PARTICLE2DTYPE type, int nSpawn, int nLife)
{
	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		if (g_a2DParticle[nCnt2DParticle].bUse == false)
		{ // パーティクルが使用されていない場合

			// 引数を代入
			g_a2DParticle[nCnt2DParticle].pos	 = pos;		// 位置
			g_a2DParticle[nCnt2DParticle].col	 = col;		// 色
			g_a2DParticle[nCnt2DParticle].nSpawn = nSpawn;	// エフェクト数
			g_a2DParticle[nCnt2DParticle].nLife	 = nLife;	// 寿命

			// 使用している状態にする
			g_a2DParticle[nCnt2DParticle].bUse = true;

			switch (type)
			{ // パーティクルの種類ごとの設定

			case PARTICLE2DTYPE_BONUS:			// ボーナスのパーティクル

				// ダメージエフェクト
				Particle2DBonus(&g_a2DParticle[nCnt2DParticle]);

				// 処理を抜ける
				break;
			}

			// 処理を抜ける
			break;
		}
	}
}

//======================================================================================================================
// ボーナスエフェクト
//======================================================================================================================
void Particle2DBonus(Particle2D *p2DParticle)
{
	// 変数を宣言
	D3DXVECTOR3 move;	// エフェクトの移動量の代入用

	for (int nCntAppear = 0; nCntAppear < p2DParticle->nSpawn; nCntAppear++)
	{ // パーティクルの 1Fで生成されるエフェクト数分繰り返す

		// ベクトルをランダムに設定
		move.x = sinf((float)(rand() % 629 - 314) / 100.0f) * 16.0f;
		move.y = cosf((float)(rand() % 629 - 314) / 100.0f) * 16.0f;

		//// 移動量を乗算
		//move.x *= 8.0f;
		//move.y *= 8.0f;

		// エフェクトの設定
		Set2DEffect
		( // 引数
			p2DParticle->pos, 
			move, 
			p2DParticle->col, 
			p2DParticle->nLife, 
			25.0f, 
			0.1f
		);
	}
}

#ifdef _DEBUG	// デバッグ処理
//======================================================================================================================
//	デバッグ処理一覧
//======================================================================================================================
//**********************************************************************************************************************
//	パーティクルの総数取得処理
//**********************************************************************************************************************
int GetNum2DParticle(void)
{
	// 変数を宣言
	int nNum2DParticle = 0;	// パーティクルの総数の確認用

	for (int nCnt2DParticle = 0; nCnt2DParticle < MAX_PARTICLE; nCnt2DParticle++)
	{ // パーティクルの最大表示数分繰り返す

		if (g_a2DParticle[nCnt2DParticle].bUse == true)
		{ // パーティクルが使用されている場合

		  // カウンターを加算
			nNum2DParticle++;
		}
	}

	// 変数の値を返す
	return nNum2DParticle;	// パーティクルの総数
}
#endif